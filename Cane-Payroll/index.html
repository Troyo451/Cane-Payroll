<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cane Cut Record</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
        background: #f9f9f9;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        margin: 0;
      }
      h2 {
        color: #333;
        margin-bottom: 20px;
      }
      label {
        display: block;
        margin-top: 15px;
        font-size: 1.1em;
        color: #555;
      }
      input, select {
        width: calc(100% - 20px);
        max-width: 300px;
        font-size: 1.3em;
        padding: 10px;
        margin-top: 5px;
        border: 1px solid #ccc;
        border-radius: 5px;
        box-sizing: border-box;
      }
      button {
        width: calc(100% - 20px);
        max-width: 300px;
        font-size: 1.6em;
        padding: 15px;
        margin-top: 25px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      }
      button:active {
        background-color: #45a049;
        box-shadow: none;
      }
      #status {
        margin-top: 30px;
        padding: 10px 15px;
        border-radius: 5px;
        font-weight: bold;
        text-align: center;
        width: calc(100% - 40px);
        max-width: 300px;
        background-color: #e0e0e0;
        color: #333;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      }
      .online-status {
        background-color: #d4edda;
        color: #155724;
      }
      .offline-status {
        background-color: #f8d7da;
        color: #721c24;
      }
      .pending-sync-status {
        background-color: #fff3cd;
        color: #856404;
      }
    </style>
  </head>
  <body>
    <h2>Cutting Record</h2>

    <label for="cutDate">Date of Cut:</label>
    <input type="date" id="cutDate">

    <label for="cutterId">Cutter ID:</label>
    <select id="cutterId">
      <option value="">Loading Cutters...</option>
      </select>

    <label for="tonsCut">Tons Cut (Tons):</label>
    <input type="number" id="tonsCut" min="0" step="0.1" placeholder="e.g., 5.5">

    <button onclick="submitForm()">Submit Cut</button>

    <div id="status">Checking connection...</div>

    <script>
      // Run these functions when the page is fully loaded
      document.addEventListener('DOMContentLoaded', () => {
        updateStatus();
        loadCutterData();
        syncOfflineData();
      
        window.addEventListener('online', updateStatus);
        window.addEventListener('offline', updateStatus);
        window.addEventListener('online', syncOfflineData);
      });

      function isOnline() {
        return navigator.onLine;
      }

      function updateStatus() {
        const statusElement = document.getElementById('status');
        const pendingCount = JSON.parse(localStorage.getItem('offlineSubmissions') || '[]').length;

        if (isOnline()) {
          if (pendingCount > 0) {
            statusElement.textContent = `Online (${pendingCount} pending sync)`;
            statusElement.className = 'pending-sync-status';
          } else {
            statusElement.textContent = 'Online ✅';
            statusElement.className = 'online-status';
          }
        } else {
          statusElement.textContent = `Offline ❌ (${pendingCount} pending)`;
          statusElement.className = 'offline-status';
        }
      }

      // Fetches cutter names and IDs from Apps Script and populates the dropdown
      function loadCutterData() {
        google.script.run
          .withSuccessHandler((response) => {
            const select = document.getElementById('cutterId');
            select.innerHTML = '<option value="">Select Cutter</option>';

            if (response.status === 'success' && Array.isArray(response.data)) {
              response.data.forEach(cutter => {
                const option = document.createElement('option');
                option.value = cutter.id;
                option.textContent = cutter.name;
                select.appendChild(option);
              });
            } else {
                console.error('Error in server response for cutters:', response.message || 'No error message provided.');
                select.innerHTML = '<option value="">Error loading cutters. Please refresh.</option>';
                alert('Error loading cutters: ' + (response.message || 'Unknown error. Please try refreshing.'));
            }
          })
          .withFailureHandler((error) => {
              console.error('Server error fetching cutter data from Apps Script:', error);
              const select = document.getElementById('cutterId');
              select.innerHTML = '<option value="">Server Error. Please refresh.</option>';
              alert('Server communication error. Failed to load cutters. Please try refreshing.');
          })
          .getCutterNamesAndIDs();
      }

      function submitForm() {
        const date = document.getElementById('cutDate').value;
        const cutterId = document.getElementById('cutterId').value;
        const tons = document.getElementById('tonsCut').value;

        if (!date) {
          alert('Please select a Date of Cut.');
          return;
        }
        if (!cutterId) {
          alert('Please select a Cutter ID.');
          return;
        }
        if (!tons || isNaN(parseFloat(tons)) || parseFloat(tons) <= 0) {
          alert('Please enter a valid amount of Tons Cut (must be a number greater than 0).');
          return;
        }

        const submission = {
          type: 'dailyCut',
          dateOfCut: date,
          cutterId: cutterId,
          tonsCut: parseFloat(tons)
        };

        if (isOnline()) {
          google.script.run
            .withSuccessHandler((response) => handleOnlineSubmissionResponse(response, submission))
            .withFailureHandler((error) => handleOnlineSubmissionError(error, submission))
            .recordDailyCut(submission.dateOfCut, submission.cutterId, submission.tonsCut);
        } else {
          saveToOfflineQueue(submission);
          alert('Offline: Data saved locally. It will sync automatically when you are back online.');
        }

        document.getElementById('cutDate').value = '';
        document.getElementById('cutterId').value = '';
        document.getElementById('tonsCut').value = '';
        updateStatus();
      }

      function saveToOfflineQueue(item) {
        let queue = JSON.parse(localStorage.getItem('offlineSubmissions')) || [];
        queue.push(item);
        localStorage.setItem('offlineSubmissions', JSON.stringify(queue));
        updateStatus();
      }

      function syncOfflineData() {
        if (!isOnline()) {
          console.log('Still offline, cannot sync.');
          return;
        }

        let queue = JSON.parse(localStorage.getItem('offlineSubmissions') || '[]');

        if (queue.length === 0) {
          console.log('No offline data to sync.');
          updateStatus();
          return;
        }

        console.log(`Attempting to sync ${queue.length} offline items.`);
        alert(`Attempting to sync ${queue.length} offline items...`);

        const promises = queue.map((item) => {
          return new Promise((resolve) => {
            if (item.type === 'dailyCut') {
              google.script.run
                .withSuccessHandler((response) => {
                  if (response.status === 'success') {
                    // Successfully synced, resolve with success status
                    resolve({ success: true, item: item });
                  } else {
                    // Server reported an error, resolve with failure status (but not a rejected promise)
                    console.error('Server reported error for item during sync:', response.message, item);
                    resolve({ success: false, item: item, error: response.message });
                  }
                })
                .withFailureHandler((error) => {
                  // Apps Script invocation error (network, script error before response)
                  console.error('Apps Script invocation failed during sync:', error, item);
                  resolve({ success: false, item: item, error: error.message || 'Unknown Apps Script error' });
                })
                .recordDailyCut(item.dateOfCut, item.cutterId, item.tonsCut);
            } else {
              // Handle other types if added, for now mark as unknown failure
              resolve({ success: false, item: item, error: 'Unknown submission type' });
            }
          });
        });

        Promise.allSettled(promises).then(results => {
          const newQueue = [];
          let syncedCount = 0;
          results.forEach(result => {
            // Check the 'value.success' property we set in our resolved promise
            if (result.status === 'fulfilled' && result.value.success) {
              syncedCount++;
            } else {
              // If the promise was fulfilled but indicated failure, or if it was rejected
              // We need to ensure that 'item' is always accessible, even if 'value' or 'reason' is missing properties.
              // Re-queue the original item itself.
              const failedItem = result.status === 'fulfilled' ? result.value.item : result.reason?.item || result.value?.item || null; // Prioritize original item from value/reason, fallback to null
              const errorMessage = result.status === 'fulfilled' ? (result.value.error || 'Server reported failure') : (result.reason?.message || 'Promise rejected unexpectedly');
              
              if (failedItem) { // Only re-queue if we have the item
                  newQueue.push(failedItem);
              }
              console.error('Failed to sync item:', errorMessage, failedItem);
            }
          });

          localStorage.setItem('offlineSubmissions', JSON.stringify(newQueue));
          updateStatus();

          if (syncedCount > 0) {
            alert(`Synced ${syncedCount} item(s) successfully!`);
          }
          if (newQueue.length > 0) {
            alert(`Could not sync ${newQueue.length} item(s). They remain in the offline queue.`);
          }
        });
      }

      function handleOnlineSubmissionResponse(response, originalSubmission) {
        if (response && response.status === 'success') {
          alert('Daily cut recorded successfully!');
          updateStatus();
        } else {
          alert('Server error: ' + (response.message || 'data not saved.') + ' It has been queued for offline sync.');
          saveToOfflineQueue(originalSubmission);
          updateStatus();
        }
      }

      function handleOnlineSubmissionError(error, originalSubmission) {
        console.error('Online submission failed:', error);
        alert('Network or server error: ' + (error.message || 'Unknown error.') + ' Data has been saved offline and will sync later.');
        saveToOfflineQueue(originalSubmission);
        updateStatus();
      }
    </script>
  </body>
</html> 